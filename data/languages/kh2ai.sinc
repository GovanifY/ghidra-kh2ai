# Main slaspec must define endianess and alignment

define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

# this is obviously wrong and will need to be edited when i understand how
# internal regs are used besides stack
define register offset=0 size=4 [
	r0 r1 r2 r3 r4 r5 r6 
    r7 r8 pc sp test broken
];

define token instr(16)
	opcode = (0, 3)
	ssub_opc = (6, 15)
	sub_opc = (4, 5)
	iarg = (14, 15);

define token instr_ext(32)
	opcode_ext = (0, 3)
	sub_opc_ext = (4, 5)
	opesub = (6, 7)
	rn = (6, 7)
	ope3 = (6, 15)
	full_ext = (0, 31)
    # the label thingy
	ope2 = (16, 31);

# relocated labels
LABEL8: reloc is ope2	[ reloc = inst_start+(ope2*2)+4; ]	{ export *:4 reloc; }
LABEL02: reloc is ope2	[ reloc = 0x10+(ope2*2); ]	{ export *:4 reloc; }

# if i'm not mistaken 0x1da4d8 1 and 2 uses two regs
# one of them or more is a status reg so i'll have to double check how it's used
attach variables [ rn ] [ _ r0 r1 _ ];

# exit values
attach values [ iarg ] [ 1 2 _ _ ];


define pcodeop system_call;



#
#
# Instructions
#
#

# standard push
:push full_ext is opcode=0 & ( sub_opc=1 | sub_opc=0 ) ; full_ext {
}


#push and add
:push2_unk0 is opcode_ext=0 & sub_opc_ext=2 & opesub=0 ; opcode {
}

# push and add to pointer
:pushap rn, ope2 is opcode_ext=0 & sub_opc_ext=2 & opesub=1 & ope2 & rn {
}

:push2_unk2  is opcode_ext=0 & sub_opc_ext=2 & opesub=2 {
}

:push LABEL02 is opcode_ext=0 & sub_opc_ext=2 & opesub=3 & LABEL02 {
}


:push3_unk0 is opcode_ext=0 & sub_opc_ext=3 & opesub=0 {
}

#push and add
:pusha rn, ope2 is opcode_ext=0 & sub_opc_ext=3 & opesub=1 & ope2 & rn {
}

#push and add
:push3_unk2 is opcode_ext=0 & sub_opc_ext=3 & opesub=2 {
}

#push and add
:push3_unk3 is opcode_ext=0 & sub_opc_ext=3 & opesub=3 {
}




# sometimes it has arguments, to check!
:pop is opcode_ext=1 {
}


:unk2 is opcode_ext=2 {
}

# pops relative address from the stack and convert it to absolute
:rela is opcode_ext=3  {
}

:unk4 is opcode=4 {
}

# 0x5 =========
# comparison ops



# convert float to int
:cfti is opcode=5 & sub_opc=0 & ssub_opc=0{
}

# convert to negative
:neg is opcode=5 & sub_opc=0 & ssub_opc=2{
}

# invert 
:inv is opcode=5 & sub_opc=0 & ssub_opc=3{
}

# is equal zero 
:eqz is opcode=5 & sub_opc=0 & ( ssub_opc=4 | ssub_opc=8 ){
}

# absolute 
:abs is opcode=5 & sub_opc=0 & ssub_opc=5{
}

# most significant bit
:msb is opcode=5 & sub_opc=0 & ssub_opc=6{
}

# inferior to one 
:info is opcode=5 & sub_opc=0 & ssub_opc=7{
}

# not equal to zero 
:neqz is opcode=5 & sub_opc=0 & ssub_opc=9{
}

# most significant bit inverted
:msbi is opcode=5 & sub_opc=0 & ssub_opc=0xA{
}

# is positive 
:ipos is opcode=5 & sub_opc=0 & ssub_opc=0xb{
}

# 0x5 --- floats

# convert int to float 
:citf is opcode=5 & sub_opc=1 & ssub_opc=0{
}

# convert to negative (float)
:negf is opcode=5 & sub_opc=1 & ssub_opc=2{
}

# ABS (float)
:absf is opcode=5 & sub_opc=1 & ssub_opc=5{
}

# inferior to zero (float)
:infzf is opcode=5 & sub_opc=1 & ssub_opc=6{
}

# inferior or equal to zero (float)
:infoezf is opcode=5 & sub_opc=1 & ssub_opc=7{
}

# equal to zero (float)
:eqzf is opcode=5 & sub_opc=1 & ssub_opc=8{
}

# not equal to zero (float)
:neqzf is opcode=5 & sub_opc=1 & ssub_opc=9{
}

# superior or equal to zero (float)
:supoezf is opcode=5 & sub_opc=1 & ssub_opc=0xA{
}

# superior to zero (float)
:supzf is opcode=5 & sub_opc=1 & ssub_opc=0xB{
}

# 0x5 =========


# 0x6 =========
# APU operations

# addition
:add is opcode=6 & sub_opc=0 & ssub_opc=0{
}

# substraction
:sub is opcode=6 & sub_opc=0 & ssub_opc=1{
}

# multiplication
:mul is opcode=6 & sub_opc=0 & ssub_opc=2{
}

# division
:div is opcode=6 & sub_opc=0 & ssub_opc=3{
}

# modulo
:mod is opcode=6 & sub_opc=0 & ssub_opc=4{
}

# logical and
:and is opcode=6 & sub_opc=0 & ssub_opc=5{
}

# logical or
:or is opcode=6 & sub_opc=0 & ssub_opc=6{
}

# logical exclusive or
:xor is opcode=6 & sub_opc=0 & ssub_opc=7{
}

# shift logical left
:sll is opcode=6 & sub_opc=0 & ssub_opc=8{
}

# shift right arithmetic
:sra is opcode=6 & sub_opc=0 & ssub_opc=9{
}

# not equal to zero (2 variable stack edition) 
:neqzv is opcode=6 & sub_opc=0 & ssub_opc=0xA{
}

# equal to zero (2 variable stack edition) 
:eqzv is opcode=6 & sub_opc=0 & ssub_opc=0xB{
}


# addition (float)
:addf is opcode=6 & sub_opc=1 & ssub_opc=0{
}
# substraction (float)
:subf is opcode=6 & sub_opc=1 & ssub_opc=1{
}
# multiplication (float)
:mulf is opcode=6 & sub_opc=1 & ssub_opc=2{
}

# division (float)
:divf is opcode=6 & sub_opc=1 & ssub_opc=3{
}

# modulo (float)
:modf is opcode=6 & sub_opc=1 & ssub_opc=4{
}

# 0x6 =========


:jmp7_unk1 LABEL8 is opcode_ext=7 & ope3=0 & LABEL8 {
  call LABEL8;
}

:jmp7_unk2 LABEL8 is opcode_ext=7 & ope3=1 & LABEL8 {
  call LABEL8;
}

:jmp7_unk3 LABEL8 is opcode_ext=7 & ope3=2 & LABEL8 {
  call LABEL8;
}

# jump 
# TODO: verify first arg! 
:jmp ope3, LABEL8 is opcode_ext=8 & LABEL8 & ope3 {
 call LABEL8;
}


# 0x9 =========

:exit iarg is opcode=9 & ( ssub_opc=0 | ssub_opc=1 ) & iarg{
}

# return
:ret is opcode=9 & ssub_opc=2{
}

# push cached -> push last cached pushed element to stack
# don't ask me, this entire ISA is cursed
:pushca is opcode=9 & ssub_opc=3{
}

# push copy -> push last pushed element to stack
:pushc is opcode=9 & ssub_opc=5{
}

# sinus; arg in radians
:sin is opcode=9 & ssub_opc=6{
}

# cosinus; arg in radians
:cos is opcode=9 & ssub_opc=7{
}

# degrees to radians
# /!\ radians are [0-2pi] in this engine
:degr is opcode=9 & ssub_opc=8{
}

# radians to degree 
:radd is opcode=9 & ssub_opc=9{
}




# 0x9 =========

#syscall
:syscall opesub,ope2 is opcode_ext=0xA & opesub & ope2 {
    r0=system_call(opesub:4,ope2:4);
}

:unkB is opcode=0xB {
}
