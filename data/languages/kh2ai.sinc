
define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

# this is obviously wrong and will need to be edited when i understand how
# internal regs are used besides stack
define register offset=0 size=4 [
	r0 r1 r2 r3 r4 r5 r6 
    r7 r8 pc sp ra broken
];

define token instr(16)
	opcode = (0, 3)
	ssub_opc = (6, 15)
	sub_opc = (4, 5)
	iarg = (14, 15);

define token instr_ext(32)
	opcode_ext = (0, 3)
	sub_opc_ext = (4, 5)
	opesub = (6, 7)
	rn = (6, 7)
	ope3 = (6, 15)
	full_ext = (0, 31)
    # the label thingy
	ope2 = (16, 31);

# relocated labels
LABEL8: reloc is ope2	[ reloc = inst_start+(ope2*2)+4; ]	{ export *:4 reloc; }
LABEL02: reloc is ope2	[ reloc = 0x10+(ope2*2); ]	{ export *:4 reloc; }

# if i'm not mistaken 0x1da4d8 1 and 2 uses two regs
# one of them or more is a status reg so i'll have to double check how it's used
attach variables [ rn ] [ _ r0 r1 _ ];

# exit values
attach values [ iarg ] [ 1 2 _ _ ];


define pcodeop system_call;
define pcodeop fmod;
define pcodeop exit;
define pcodeop cos;
define pcodeop sin;
define pcodeop radians_to_degrees;
define pcodeop degrees_to_radians;


macro push(v) {
  *[ram]:4 sp = v;
  sp = sp + 4;
}

macro pop(v) {
  sp = sp - 4;
  v = *[ram]:4 sp;
}

#
#
# Instructions
#
#


# 0x1 =========

# standard push
:push full_ext is opcode=0 & ( sub_opc=1 | sub_opc=0 ) ; full_ext {
    push(full_ext:4);
}


#push and add
:push2_unk0 is opcode_ext=0 & sub_opc_ext=2 & opesub=0 ; opcode {
}

# push and add to pointer
:pushap rn, ope2 is opcode_ext=0 & sub_opc_ext=2 & opesub=1 & ope2 & rn {
}

:push2_unk2  is opcode_ext=0 & sub_opc_ext=2 & opesub=2 {
}

:push LABEL02 is opcode_ext=0 & sub_opc_ext=2 & opesub=3 & LABEL02 {
    # this is wrong! it pushes the pointer, not the data
    push(LABEL02:4);
}


:push3_unk0 is opcode_ext=0 & sub_opc_ext=3 & opesub=0 {
}

#push and add
:pusha rn, ope2 is opcode_ext=0 & sub_opc_ext=3 & opesub=1 & ope2 & rn {
}

#push and add
:push3_unk2 is opcode_ext=0 & sub_opc_ext=3 & opesub=2 {
}

#push and add
:push3_unk3 is opcode_ext=0 & sub_opc_ext=3 & opesub=3 {
}

# 0x1 =========


# sometimes it has arguments, to check!
:pop is opcode_ext=1 {
}


:unk2 is opcode_ext=2  {
}

# pops relative address from the stack and convert it to absolute
:rela is opcode_ext=3  {
}

:unk4 is opcode=4  {
}

# 0x5 =========
# comparison ops



# convert float to int
:cfti is opcode=5 & sub_opc=0 & ssub_opc=0{
    local tmp:4 = sp;
    pop(tmp);
    tmp = round(tmp);
    push(tmp);
}

# convert to negative
:neg is opcode=5 & sub_opc=0 & ssub_opc=2{
    local tmp:4 = sp;
    pop(tmp);
    tmp = tmp;
    tmp=-tmp;
    push(tmp);
}

# invert 
:inv is opcode=5 & sub_opc=0 & ssub_opc=3{
    local tmp:4 = sp;
    pop(tmp);
    tmp = ~tmp;
    push(tmp);
}

# is equal zero 
:eqz is opcode=5 & sub_opc=0 & ( ssub_opc=4 | ssub_opc=8 ){
    local tmp:4 = sp;
    pop(tmp);
    local ret = (tmp == 0);
    push(ret);
}

# absolute 
:abs is opcode=5 & sub_opc=0 & ssub_opc=5{
    local tmp:4 = sp;
    pop(tmp);
    if(tmp s<= 0) goto <min>;
        goto <done>;
    <min>
        tmp=-tmp;     
    <done>
        push(tmp);
}

# most significant bit
:msb is opcode=5 & sub_opc=0 & ssub_opc=6{
    local tmp:4 = sp;
    pop(tmp);
    tmp = tmp >> 0x1F;
    push(tmp);
}

# inferior to one 
:info is opcode=5 & sub_opc=0 & ssub_opc=7{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp s< 1));
}

# not equal to zero 
:neqz is opcode=5 & sub_opc=0 & ssub_opc=9{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp != 0));
}

# most significant bit inverted
:msbi is opcode=5 & sub_opc=0 & ssub_opc=0xA{
    local tmp:4 = sp;
    pop(tmp);
    tmp = tmp >> 0x1F;
    push(~tmp);
}

# is positive 
:ipos is opcode=5 & sub_opc=0 & ssub_opc=0xb{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp s> 0));
}

# 0x5 --- floats

# convert int to float 
:citf is opcode=5 & sub_opc=1 & ssub_opc=0{
    local tmp:4 = sp;
    pop(tmp);
    tmp=int2float(tmp);
    push(tmp);
}

# convert to negative (float)
:negf is opcode=5 & sub_opc=1 & ssub_opc=2{
}

# ABS (float)
:absf is opcode=5 & sub_opc=1 & ssub_opc=5{
    local tmp:4 = sp;
    pop(tmp);
    tmp=abs(tmp);
    push(tmp);
}

# inferior to zero (float)
:infzf is opcode=5 & sub_opc=1 & ssub_opc=6{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp f< 0));
}

# inferior or equal to zero (float)
:infoezf is opcode=5 & sub_opc=1 & ssub_opc=7{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp f<= 0));
}

# equal to zero (float)
:eqzf is opcode=5 & sub_opc=1 & ssub_opc=8{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp f== 0));
}

# not equal to zero (float)
:neqzf is opcode=5 & sub_opc=1 & ssub_opc=9{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp f!= 0));
}

# superior or equal to zero (float)
:supoezf is opcode=5 & sub_opc=1 & ssub_opc=0xA{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp f>= 0));
}

# superior to zero (float)
:supzf is opcode=5 & sub_opc=1 & ssub_opc=0xB{
    local tmp:4 = sp;
    pop(tmp);
    push((tmp f> 0));
}

# 0x5 =========


# 0x6 =========
# APU operations

# addition
:add is opcode=6 & sub_opc=0 & ssub_opc=0{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2+tmp);
}

# substraction
:sub is opcode=6 & sub_opc=0 & ssub_opc=1{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2-tmp);
}

# multiplication
:mul is opcode=6 & sub_opc=0 & ssub_opc=2{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 * tmp);
}

# division
:div is opcode=6 & sub_opc=0 & ssub_opc=3{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 s/ tmp);
}

# modulo
:mod is opcode=6 & sub_opc=0 & ssub_opc=4{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 s% tmp);
}

# logical and
:and is opcode=6 & sub_opc=0 & ssub_opc=5{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2&tmp);
}

# logical or
:or is opcode=6 & sub_opc=0 & ssub_opc=6{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2|tmp);
}

# logical exclusive or
:xor is opcode=6 & sub_opc=0 & ssub_opc=7{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2^tmp);
}

# shift logical left
:sll is opcode=6 & sub_opc=0 & ssub_opc=8{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2<<(tmp&0x1F));
}

# shift right arithmetic
:sra is opcode=6 & sub_opc=0 & ssub_opc=9{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2>>(tmp&0x1F));
}

# not equal to zero (2 variable stack edition) 
:eqzv is opcode=6 & sub_opc=0 & ssub_opc=0xA{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    local ret:4 = 1;
    if(tmp!=0) goto <next>;
        goto <end>;
    <next>
        if(tmp2==0) goto <end>;
            ret=0;
    <end>
    push(ret);
}

# equal to zero (2 variable stack edition) 
:neqzv is opcode=6 & sub_opc=0 & ssub_opc=0xB{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    local ret:4 = 1;
    if(tmp==0) goto <next>;
        goto <end>;
    <next>
        if(tmp2!=0) goto <end>;
            ret=0;
    <end>
    push(ret);
}


# addition (float)
:addf is opcode=6 & sub_opc=1 & ssub_opc=0{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 f+ tmp);
}
# substraction (float)
:subf is opcode=6 & sub_opc=1 & ssub_opc=1{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 f- tmp);
}

# multiplication (float)
:mulf is opcode=6 & sub_opc=1 & ssub_opc=2{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 f* tmp);
}

# division (float)
:divf is opcode=6 & sub_opc=1 & ssub_opc=3{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    push(tmp2 f/ tmp);
}

# modulo (float)
:modf is opcode=6 & sub_opc=1 & ssub_opc=4{
    local tmp:4 = sp;
    local tmp2:4 = sp;
    pop(tmp);
    pop(tmp2);
    # primitive doesn't exist, so we do with what we can
    local ret:4 = fmod(tmp2, tmp);
    push(ret);
}

# 0x6 =========


:jmp7_unk1 LABEL8 is opcode_ext=7 & ope3=0 & LABEL8 {
  call LABEL8;
}

:jmp7_unk2 LABEL8 is opcode_ext=7 & ope3=1 & LABEL8 {
  call LABEL8;
}

:jmp7_unk3 LABEL8 is opcode_ext=7 & ope3=2 & LABEL8 {
  call LABEL8;
}

# jump 
# TODO: verify first arg! 
:jmp ope3, LABEL8 is opcode_ext=8 & LABEL8 & ope3 {
  call LABEL8;
}


# 0x9 =========

:exit iarg is opcode=9 & ( ssub_opc=0 | ssub_opc=1 ) & iarg{
    exit(iarg:1);
}

# return
:ret is opcode=9 & ssub_opc=2{
  return[ra];
}

# push cached -> push last cached pushed element to stack
# don't ask me, this entire ISA is cursed
:pushca is opcode=9 & ssub_opc=3{
}

# push copy -> push last pushed element to stack
:pushc is opcode=9 & ssub_opc=5{
}

# sinus; arg in radians
:sin is opcode=9 & ssub_opc=6{
    local tmp:4 = sp;
    pop(tmp);
    local ret:4 = sin(tmp);
    push(ret);
}

# cosinus; arg in radians
:cos is opcode=9 & ssub_opc=7{
    local tmp:4 = sp;
    pop(tmp);
    local ret:4 = cos(tmp);
    push(ret);
}

# degrees to radians
# /!\ radians are [0-2pi] in this engine
:degr is opcode=9 & ssub_opc=8{
    local tmp:4 = sp;
    pop(tmp);
    local ret:4 = degrees_to_radians(tmp);
    push(ret);
}

# radians to degree 
:radd is opcode=9 & ssub_opc=9{
    local tmp:4 = sp;
    pop(tmp);
    local ret:4 = radians_to_degrees(tmp);
    push(ret);
}




# 0x9 =========

#syscall
:syscall opesub,ope2 is opcode_ext=0xA & opesub & ope2 {
    system_call(opesub:4,ope2:4);
}

:unkB is opcode=0xB {
}
