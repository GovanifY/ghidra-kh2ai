# Main slaspec must define endianess and alignment

define space ram type=ram_space size=4 wordsize=1 default;

define space register type=register_space size=4;

# the rx are used simply to store arguments of instr
define register offset=0 size=4 [
	r0 r1 r2 r3 r4 r5 r6 
    r7 r8 pc sp test broken
];

define token instr(8)
	op1 = (0, 3)
	op2 = (4, 7)
	op3 = (6, 7)
	rn = (4, 7);

define token instr_advanced(16)
	opa1 = (0, 3)
	opa4 = (6, 15)
	opa2 = (4, 5);
	#opa3 = (5, 9);



# needed a full 4bit mapping 
attach variables [ rn ] [ broken r0 r1 broken broken r0 r1 broken broken r0 r1 broken broken r0 r1 broken ];

# please find a way to make it better
@define AND_THREE "(op2=3 | op2=7 | op2=11 | op2=15)"
@define AND_TWO "(op2=2 | op2=6 | op2=10 | op2=14)" 
@define AND_ONE "(op2=1 | op2=5 | op2=9 | op2=13)"  
@define AND_ZERO "(op2=0 | op2=4 | op2=8 | op2=12)" 




define token extnormal(8)
    in = (0,7);

define token extsmall(24)
    ib = (8, 23)
    ibl = (0, 23);

define token ext(40)
	il = (8, 39);

define pcodeop system_call;



#
#
# Instructions
#
#

#push
:push il is op1=0 & ( $(AND_ZERO) | $(AND_ONE) ); il {
    *[ram]:4 sp = il:4;
    sp=sp+4;
}

#push and add
#TODO: 3 isn't handled exactly the same as 2, to check?
:pusha rn,ib is op1=0 & ( $(AND_TWO) | $(AND_THREE) ) & rn ; ib {
    *[ram]:4 sp = rn:4+ib:4;
    sp=sp+4;
}

:pop ibl is op1=1 ; ibl {
    sp=sp-4;
}


:unk2 is op1=2 ; ib {
}

# pops relative address from the stack and convert it to absolute
:rela is op1=3 ; ib {
}

:unk4 is op1=4 ; in {
}

# 0x5 =========
# comparison ops



# convert float to int
:cfti is opa1=5 & opa2=0 & opa4=0{
}

# convert to negative
:neg is opa1=5 & opa2=0 & opa4=2{
}

# invert 
:inv is opa1=5 & opa2=0 & opa4=3{
}

# is equal zero 
:eqz is opa1=5 & opa2=0 & ( opa4=4 | opa4=8 ){
}

# absolute 
:abs is opa1=5 & opa2=0 & opa4=5{
}

#TODO: implement 6

# inferior to one 
:info is opa1=5 & opa2=0 & opa4=7{
}

# not equal to zero 
:neqz is opa1=5 & opa2=0 & opa4=9{
}

#TODO: implement 0xA

# is positive 
:ipos is opa1=5 & opa2=0 & opa4=0xb{
}

# 0x5 --- floats

# convert int to float 
:citf is opa1=5 & opa2=1 & opa4=0{
}

# convert to negative (float)
:negf is opa1=5 & opa2=1 & opa4=2{
}

# ABS (float)
:absf is opa1=5 & opa2=1 & opa4=5{
}

# inferior to zero (float)
:infzf is opa1=5 & opa2=1 & opa4=6{
}

# inferior or equal to zero (float)
:infoezf is opa1=5 & opa2=1 & opa4=7{
}

# equal to zero (float)
:eqzf is opa1=5 & opa2=1 & opa4=8{
}

# equal to zero (float)
:neqzf is opa1=5 & opa2=1 & opa4=9{
}

# superior or equal to zero (float)
:supoezf is opa1=5 & opa2=1 & opa4=0xA{
}

# superior to zero (float)
:supzf is opa1=5 & opa2=1 & opa4=0xB{
}

# 0x5 =========


# 0x6 =========
# APU operations

# addition
:add is opa1=6 & opa2=0 & opa4=0{
}

# substraction
:sub is opa1=6 & opa2=0 & opa4=1{
}

# multiplication
:mul is opa1=6 & opa2=0 & opa4=2{
}

# division
:div is opa1=6 & opa2=0 & opa4=3{
}

# modulo
:mod is opa1=6 & opa2=0 & opa4=4{
}

# logical and
:and is opa1=6 & opa2=0 & opa4=5{
}

# logical or
:or is opa1=6 & opa2=0 & opa4=6{
}

# logical exclusive or
:xor is opa1=6 & opa2=0 & opa4=7{
}

# shift logical left
:sll is opa1=6 & opa2=0 & opa4=8{
}

# shift right arithmetic
:sra is opa1=6 & opa2=0 & opa4=9{
}

# not equal to zero (2 variable stack edition) 
:neqzv is opa1=6 & opa2=0 & opa4=0xA{
}

# equal to zero (2 variable stack edition) 
:eqzv is opa1=6 & opa2=0 & opa4=0xB{
}


# addition (float)
:addf is opa1=6 & opa2=1 & opa4=0{
}
# substraction (float)
:subf is opa1=6 & opa2=1 & opa4=1{
}
# multiplication (float)
:mulf is opa1=6 & opa2=1 & opa4=2{
}

# division (float)
:divf is opa1=6 & opa2=1 & opa4=3{
}

# MOST LIKELY IS A MOD BUT HECK I AIN'T REVERSING THAT
# modulo (float)
:modf is opa1=6 & opa2=1 & opa4=4{
}

# 0x6 =========


:unk7 is op1=7  ; ib {
}
:unk8 is op1=8 ; ib{
}

# return
:ret is opa1=9 & opa2=2{
}

:unk9 is opa1=9 & opa2{
}

#syscall
:syscall op3,ib is op1=0xA & op3 ; ib {
    r0=system_call();
}

:unkB is op1=0xB ; in{
}
